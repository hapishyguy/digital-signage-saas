// Digital Signage Backend v2 - Cloudflare Worker

const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, Content-Disposition, X-Content-Type-Options',
};

const DEFAULT_LIMITS = {
  maxScreens: 5,
  maxPlaylists: 5,
  maxStorage: 500 * 1024 * 1024, // 500MB in bytes
};

// --- Standard Worker Utility Functions ---

function json(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json', ...CORS_HEADERS },
  });
}

function generateCode(length = 6) {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
}

async function hashPassword(password) {
  const data = new TextEncoder().encode(password);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return btoa(String.fromCharCode(...new Uint8Array(hash)));
}

async function createJWT(payload, secret) {
  const header = { alg: 'HS256', typ: 'JWT' };
  const enc = (obj) => btoa(JSON.stringify(obj)).replace(/=/g, '');
  const body = `${enc(header)}.${enc({ ...payload, exp: Date.now() + 7 * 24 * 60 * 60 * 1000 })}`;
  const key = await crypto.subtle.importKey('raw', new TextEncoder().encode(secret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const sig = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(body));
  return `${body}.${btoa(String.fromCharCode(...new Uint8Array(sig))).replace(/=/g, '')}`;
}

async function verifyJWT(token, secret) {
  try {
    const [header, payload, sig] = token.split('.');
    const key = await crypto.subtle.importKey('raw', new TextEncoder().encode(secret), { name: 'HMAC', hash: 'SHA-256' }, false, ['verify']);
    const valid = await crypto.subtle.verify('HMAC', key, Uint8Array.from(atob(sig), c => c.charCodeAt(0)), new TextEncoder().encode(`${header}.${payload}`));
    if (!valid) return null;
    const data = JSON.parse(atob(payload));
    if (data.exp && data.exp < Date.now()) return null;
    return data;
  } catch { return null; }
}

async function authenticate(request, env) {
  const auth = request.headers.get('Authorization');
  if (!auth?.startsWith('Bearer ')) return null;
  return verifyJWT(auth.slice(7), env.JWT_SECRET);
}

// --- InstantDB Helper Functions ---

// Corrected: Uses Bearer token and App-Id header
async function instantDB(env, action, data) {
  const res = await fetch('https://api.instantdb.com/admin/transact', {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json', 
      'Authorization': `Bearer ${env.INSTANTDB_ADMIN_TOKEN}`,
      'App-Id': env.INSTANTDB_APP_ID 
    },
    body: JSON.stringify({ ...data, 'app-id': env.INSTANTDB_APP_ID })
  });
  return res.json();
}

// Corrected: Uses Bearer token and App-Id header
async function instantQuery(env, query) {
  const res = await fetch('https://api.instantdb.com/admin/query', {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json', 
      'Authorization': `Bearer ${env.INSTANTDB_ADMIN_TOKEN}`,
      'App-Id': env.INSTANTDB_APP_ID
    },
    body: JSON.stringify({ query, 'app-id': env.INSTANTDB_APP_ID })
  });
  return res.json();
}

// Get active playlist based on schedule
function getActivePlaylist(screen, schedules, now = new Date()) {
  if (!schedules?.length) return screen.defaultPlaylistId;
  
  const dayOfWeek = now.getDay(); 
  const currentMinutes = now.getHours() * 60 + now.getMinutes();
  
  const activeSchedule = schedules
    .filter(s => s.screenId === screen.id || s.groupId === screen.groupId)
    .filter(s => {
      const days = JSON.parse(s.days || '[]');
      if (!days.includes(dayOfWeek)) return false;
      const [startH, startM] = s.startTime.split(':').map(Number);
      const [endH, endM] = s.endTime.split(':').map(Number);
      const start = startH * 60 + startM;
      const end = endH * 60 + endM;
      if (start > end) { // Cross midnight
        return currentMinutes >= start || currentMinutes < end;
      }
      return currentMinutes >= start && currentMinutes < end;
    })
    .sort((a, b) => (b.priority || 0) - (a.priority || 0))[0];
  
  return activeSchedule?.playlistId || screen.defaultPlaylistId;
}


// --- Main Worker Fetch Handler ---
export default {
  async fetch(request, env) {
    if (request.method === 'OPTIONS') return new Response(null, { headers: CORS_HEADERS });

    const url = new URL(request.url);
    const path = url.pathname;
    const method = request.method;

    try {
      // --- AUTH ROUTES ---
      if (path === '/api/auth/register' && method === 'POST') {
        const { email, password, name } = await request.json();
        const id = crypto.randomUUID();
        const hashedPw = await hashPassword(password);
        
        // Check for existing user
        const { users } = await instantQuery(env, { users: { $: { where: { email } } } });
        if (users && users.length > 0) return json({ error: 'User already exists' }, 409);
        
        // Create user and a corresponding limits record in customerLimits with default values
        await instantDB(env, 'transact', { 
            steps: [
              ['update', 'users', id, { 
                    email, 
                    password: hashedPw, 
                    name, 
                    createdAt: Date.now(), 
                    role: 'customer',
                }],
              ['update', 'customerLimits', id, { // Use customer ID as the limits ID
                    id, 
                    maxScreens: DEFAULT_LIMITS.maxScreens,
                    maxPlaylists: DEFAULT_LIMITS.maxPlaylists,
                    maxStorage: DEFAULT_LIMITS.maxStorage,
                    createdAt: Date.now(),
                }]
            ] 
        });

        const token = await createJWT({ userId: id, email, role: 'customer' }, env.JWT_SECRET);
        return json({ token, user: { id, email, name, role: 'customer' } });
      }

      if (path === '/api/auth/login' && method === 'POST') {
        const { email, password } = await request.json();
        
        const { users } = await instantQuery(env, { users: { $: { where: { email } } } });
        const user = users?.[0];
        
        if (!user || await hashPassword(password) !== user.password) {
          return json({ error: 'Invalid credentials' }, 401);
        }
        
        // Add lastLogin update logic
        const now = Date.now();
        await instantDB(env, 'transact', { 
            steps: [['update', 'users', user.id, [['set', 'lastLogin', now]]]] 
        });
        user.lastLogin = now; // Update in memory for response

        const token = await createJWT({ userId: user.id, email: user.email, role: user.role }, env.JWT_SECRET);
        return json({ token, user: { id: user.id, email: user.email, name: user.name, role: user.role, lastLogin: user.lastLogin } });
      }

      // --- SETUP ROUTE (UNAUTHENTICATED) ---
      if (path === '/api/setup/check' && method === 'GET') {
        // FIXED: Check specifically for the 'super_admin' role to avoid false positives
        const response = await instantQuery(env, { 
            users: { $: { where: { role: 'super_admin' } } } 
        });
        
        if (response.error || response.Error) {
             console.error('InstantDB Setup Check Error:', response.error || response.Error);
             return json({ error: 'Database connection failed during setup check.' }, 500);
        }
        
        const { users } = response;
        const setupComplete = Array.isArray(users) && users.length > 0;
        return json({ setupComplete });
      }

      if (path === '/api/setup/complete' && method === 'POST') {
        // Check again using the corrected query
        const checkRes = await instantQuery(env, { users: { $: { where: { role: 'super_admin' } } } });
        if (checkRes.users && checkRes.users.length > 0) {
            return json({ error: 'Setup already completed. Please log in.' }, 409);
        }

        const { email, password, name } = await request.json();
        if (!email || !password || !name) return json({ error: 'Missing fields' }, 400);

        const id = crypto.randomUUID();
        const hashedPw = await hashPassword(password);

        const tx = await instantDB(env, 'transact', {
            steps: [
                ['update', 'users', id, { 
                    email, 
                    password: hashedPw, 
                    name, 
                    createdAt: Date.now(), 
                    role: 'super_admin', // FIXED: Correct role name
                }],
            ] 
        });

        if (tx.error || tx.Error) return json({ error: `Setup Failed: ${tx.error || tx.Error}` }, 500);

        const token = await createJWT({ userId: id, email, role: 'super_admin' }, env.JWT_SECRET);
        return json({ token, user: { id, email, name, role: 'super_admin' } });
      }

      // --- AUTHENTICATED ROUTES ---
      const user = await authenticate(request, env);
      if (!user) return json({ error: 'Unauthorized' }, 401);

      // === SUPER ADMIN ROUTES ===
      // FIXED: Use correct role check
      if (user.role === 'super_admin') { 
        
        if (path === '/api/admin/stats' && method === 'GET') {
          // Query for customers (users who are NOT super_admin)
          const { users, screens, media, playlists } = await instantQuery(env, {
            users: { $: { where: { role: 'customer' } } },
            screens: {},
            media: {},
            playlists: {}
          });
          
          const totalStorageUsed = (media || []).reduce((sum, m) => sum + (m.size || 0), 0);

          return json({
            totalCustomers: (users || []).length,
            totalScreens: (screens || []).length,
            totalMedia: (media || []).length,
            totalPlaylists: (playlists || []).length,
            totalStorageUsed,
          });
        }

        if (path === '/api/admin/customers' && method === 'GET') {
          
          // 1. Fetch Users (Customers only)
          const { users } = await instantQuery(env, { 
            users: { $: { where: { role: 'customer' } } } 
          });

          // 2. Fetch Limits
          const { customerLimits } = await instantQuery(env, { 
            customerLimits: {} 
          });

          // 3. Robust Merge Logic (using Map for efficient O(N) join)
          const limitsMap = new Map((customerLimits || []).map(l => [l.id, l]));
          
          const mergedCustomers = (users || []).map(c => {
            const limits = limitsMap.get(c.id);
            
            return {
              ...c, 
              lastLogin: c.lastLogin || null, 
              
              // Limits from customerLimits, falling back to DEFAULT_LIMITS
              maxScreens: limits?.maxScreens || DEFAULT_LIMITS.maxScreens,
              maxPlaylists: limits?.maxPlaylists || DEFAULT_LIMITS.maxPlaylists,
              maxStorage: limits?.maxStorage || DEFAULT_LIMITS.maxStorage,
              storageUsed: limits?.storageUsed || 0,
            };
          });

          return json(mergedCustomers);
        }

        if (path.match(/^\/api\/admin\/customers\/[\w-]+\/limits$/) && method === 'PUT') {
          const customerId = path.split('/')[4];
          const { maxScreens, maxPlaylists, maxStorage } = await request.json();
          
          await instantDB(env, 'transact', { 
            steps: [
              ['update', 'customerLimits', customerId, { 
                id: customerId, 
                maxScreens: Math.max(0, maxScreens), 
                maxPlaylists: Math.max(0, maxPlaylists), 
                // Frontend sends MB, DB stores Bytes
                maxStorage: Math.max(0, maxStorage) * 1024 * 1024, 
                updatedAt: Date.now(),
              }]
            ] 
          });

          return json({ success: true });
        }
      } // End Super Admin Routes

      // ... (other customer/user routes) ...
      
      // --- CATCH ALL ---
      return json({ error: 'Not found' }, 404);
      
    } catch (err) {
      console.error(err);
      // Ensure we catch ALL errors and return a JSON response
      return json({ error: 'Internal Server Error: ' + err.message }, 500);
    }
  }
};
